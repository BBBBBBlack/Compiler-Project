#include "FA.hpp"

void FA::setOutputFile(std::string fileName)
{
    outputFile = new std::ofstream(); // 申请内存
    std::string folderPath = fileName.substr(0, fileName.find_last_of("/\\"));
    std::filesystem::create_directories(folderPath);
    outputFile->open(fileName, std::ios::trunc);
    if (!outputFile->is_open())
    {
        perror("打开文件失败");
    }

    *outputFile << "Generated by \n"
                << "```text\n"
                << BANNER
                << "\n```\n";

    // 向outFile写入当前时间
    std::time_t currentTime = std::time(nullptr);
    *outputFile << "Generate time: " << std::asctime(std::localtime(&currentTime));
    outputFile->flush();
}

void FA::printFA()
{
    // 打印正则表达式集合
    if (!printRegexFlag)
    {
        *outputFile << "## 正则表达式集合" << std::endl;
        for (auto &pa : *paVec)
        {
            *outputFile << "- " << pa.pattern << std::endl;
        }
        printRegexFlag = true;
    }

    // 打印字母表
    if (!printAlphabetFlag)
    {
        *outputFile << std::endl
                    << "## 字母表" << std::endl;
        for (auto &letter : alphabet)
        {
            *outputFile << letter << " ";
        }
        *outputFile << std::endl;
        printAlphabetFlag = true;
    }

    // 打印状态图
    *outputFile << std::endl
                << "## " << FAType << "状态图" << std::endl;

    *outputFile << "```mermaid" << std::endl;
    *outputFile << "graph LR" << std::endl;

    std::stack<int> stateStack;
    std::unordered_map<int, bool> visited;
    stateStack.push(startStateID);
    // dfs 打印状态
    int i = 1;
    while (!stateStack.empty())
    {
        int stateID = stateStack.top();
        stateStack.pop();
        visited[stateID] = true;

        std::string debugMessage = ""; // 调试信息, 默认为空

        if (debugMode)
        {
            debugMessage = "<" + std::to_string(stateID) + (states[stateID].note.empty() ? "" : (", " + states[stateID].note)) + ">";
        }
        // print节点
        if (stateID == startStateID)
        {
            *outputFile << stateID << "((\"STAR<" << debugMessage << "\"))" << std::endl;
        }
        else if (states[stateID].isAccepting)
        {
            *outputFile << stateID << "((\"END" << debugMessage << "\"))" << std::endl;
        }
        else
        {
            *outputFile << stateID << "((\"" << i++ << debugMessage << "\"))" << std::endl;
        }

        // print符号边
        for (auto &trans : states[stateID].trans)
        {
            *outputFile << stateID << "--" << trans.first << "-->" << trans.second << std::endl;
            if (visited.find(trans.second) == visited.end())
            {
                stateStack.push(trans.second);
                visited[trans.second] = true;
            }
        }

        // print空边
        for (auto &epsilonTrans : states[stateID].epsilonTrans)
        {
            *outputFile << stateID << "--" << EPSILON_CHAR << "-->" << epsilonTrans << std::endl;
            if (visited.find(epsilonTrans) == visited.end())
            {
                stateStack.push(epsilonTrans);
                visited[epsilonTrans] = true;
            }
        }
        *outputFile << std::endl;
    }

    *outputFile << "```" << std::endl;
    outputFile->flush();
}

int FA::addState(bool isAccepting, FAStateVec &states)
{
    return addState(isAccepting, NullAction, states);
}

int FA::addState(bool isAccepting, ActionFunction action, FAStateVec &states)
{
    FAState faState(states.size(), {}, {}, isAccepting, action);
    states.push_back(faState);
    return states.size() - 1;
}

void FA::addEdge(int fromStateID, int toStateID, char symbol, FAStateVec &states)
{
    std::string str_sym(1, symbol);
    states[fromStateID].trans[str_sym] = toStateID;
}

void FA::addEdge(int fromStateID, int toStateID, std::string symbol, FAStateVec &states)
{
    if (symbol == EPSILON) // 空边
    {
        states[fromStateID].epsilonTrans.push_back(toStateID);
    }
    else // 转移条件
    {
        states[fromStateID].trans[symbol] = toStateID;
    }
}

/**
 * @brief 获取一个状态的epsilon闭包
 * @param stateID 状态ID
 * @param visited 访问标记(用于避免重复访问)
 */
StateSet FA::epsilonClosure(int stateID, std::unordered_map<int, bool> &visited, FAStateVec &states)
{
    std::stack<int> stateStack;
    stateStack.push(stateID);
    StateSet result;
    while (!stateStack.empty())
    {
        int stateID = stateStack.top();
        stateStack.pop();
        result.set.insert(stateID);
        visited[stateID] = true;
        for (auto &epsilonTrans : states[stateID].epsilonTrans)
        {
            if (visited.find(epsilonTrans) == visited.end())
            {
                stateStack.push(epsilonTrans);
                result.isAccepting = result.isAccepting || states[epsilonTrans].isAccepting;
                visited[epsilonTrans] = true;
            }
        }
    }
    return result;
}

/**
 * @brief 获取一个状态集的epsilon闭包
 * @param stateSet 状态集
 * @param visited 访问标记(用于避免重复访问)
 */
StateSet FA::epsilonClosure(StateSet stateSet, std::unordered_map<int, bool> &visited, FAStateVec &states)
{
    // TODO 空闭包是否需要加入自身?
    StateSet result = stateSet;
    for (auto &stateID : stateSet.set)
    {
        StateSet closure = epsilonClosure(stateID, visited, states);
        result.set.insert(closure.set.begin(), closure.set.end());
        result.isAccepting = result.isAccepting || closure.isAccepting;
    }
    return result;
}

/**
 * @brief 获取一个状态集的转移闭包
 * @param stateSet 状态集
 * @param symbol 转移条件
 */
StateSet FA::move(StateSet stateSet, std::string symbol, FAStateVec &states)
{
    StateSet result;
    // 遍历状态集
    for (auto &stateID : stateSet.set)
    {
        // 查看当前状态是否有symbol转移
        if (states[stateID].trans.find(symbol) != states[stateID].trans.end())
        {
            int nextStateID = states[stateID].trans[symbol];
            result.set.insert(nextStateID);
            result.isAccepting = result.isAccepting || states[nextStateID].isAccepting;
        }
    }
    return result;
}