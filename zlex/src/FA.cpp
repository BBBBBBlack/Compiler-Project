#include "FA.hpp"

void FA::setOutputFile(std::string fileName)
{
    outputFile = new std::ofstream();
    std::string folderPath = fileName.substr(0, fileName.find_last_of("/\\"));
    std::filesystem::create_directories(folderPath);
    outputFile->open(fileName, std::ios::trunc);
    if (!outputFile->is_open())
    {
        perror("打开文件失败");
    }

    *outputFile << "Generated by \n"
                << "```text\n"
                << BANNER
                << "\n```\n";

    // 向outFile写入当前时间
    std::time_t currentTime = std::time(nullptr);
    *outputFile << "Generate time: " << std::asctime(std::localtime(&currentTime));
    outputFile->flush();
}

void FA::printFA()
{
    // 打印正则表达式集合
    if (!printRegexFlag)
    {
        *outputFile << "## 正则表达式集合" << std::endl;
        for (auto &regex : regexVec)
        {
            *outputFile << "- " << regex << std::endl;
        }
        printRegexFlag = true;
    }

    // 打印状态图

    *outputFile << std::endl
                << "## " << FAType << "状态图" << std::endl;

    *outputFile << "```mermaid" << std::endl;
    *outputFile << "graph LR" << std::endl;

    std::stack<int> stateStack;
    std::unordered_map<int, bool> visited;
    stateStack.push(startStateID);
    // dfs 打印状态
    int i = 1;
    while (!stateStack.empty())
    {
        int stateID = stateStack.top();
        stateStack.pop();
        visited[stateID] = true;

        // print节点
        if (debugMode)
        {
            // print节点
            if (stateID == startStateID)
            {
                *outputFile << stateID << "((START<" << stateID << ">))" << std::endl;
            }
            else if (states[stateID].isAccepting)
            {
                *outputFile << stateID << "((END<" << stateID << ">))" << std::endl;
            }
            else
            {
                *outputFile << stateID << "((" << i++ << "<" << stateID << ">"
                            << "))" << std::endl;
            }
        }
        else
        {
            if (states[stateID].isAccepting)
            {
                *outputFile << stateID << "((END))" << std::endl;
            }
            else if (stateID == startStateID)
            {
                *outputFile << stateID << "((START))" << std::endl;
            }
            else
            {
                *outputFile << stateID << "((" << i++ << "))" << std::endl;
            }
        }

        // print符号边
        for (auto &trans : states[stateID].trans)
        {
            *outputFile << stateID << "--" << trans.first << "-->" << trans.second << std::endl;
            if (visited.find(trans.second) == visited.end())
            {
                stateStack.push(trans.second);
                visited[trans.second] = true;
            }
        }

        // print空边
        for (auto &epsilonTrans : states[stateID].epsilonTrans)
        {
            *outputFile << stateID << "--" << EPSILON_CHAR << "-->" << epsilonTrans << std::endl;
            if (visited.find(epsilonTrans) == visited.end())
            {
                stateStack.push(epsilonTrans);
                visited[epsilonTrans] = true;
            }
        }
        *outputFile << std::endl;
    }

    *outputFile << "```" << std::endl;
    outputFile->flush();
}

int FA::addState(bool isAccepting, FAStateVec &states)
{
    FAState faState(states.size(), {}, {}, isAccepting);
    states.push_back(faState);
    return states.size() - 1;
}

void FA::addEdge(int fromStateID, int toStateID, char symbol, FAStateVec &states)
{
    std::string str_sym(1, symbol);
    states[fromStateID].trans[str_sym] = toStateID;
}

void FA::addEdge(int fromStateID, int toStateID, std::string symbol, FAStateVec &states)
{
    if (symbol == EPSILON) // 空边
    {
        states[fromStateID].epsilonTrans.push_back(toStateID);
    }
    else // 转移条件
    {
        states[fromStateID].trans[symbol] = toStateID;
    }
}

/**
 * @brief 获取一个状态的epsilon闭包
 * @param stateID 状态ID
 * @param visited 访问标记(用于避免重复访问)
 */
StateSet FA::epsilonClosure(int stateID, std::unordered_map<int, bool> &visited, FAStateVec &states)
{
    std::stack<int> stateStack;
    stateStack.push(stateID);
    StateSet result;
    while (!stateStack.empty())
    {
        int stateID = stateStack.top();
        stateStack.pop();
        result.set.insert(stateID);
        visited[stateID] = true;
        for (auto &epsilonTrans : states[stateID].epsilonTrans)
        {
            if (visited.find(epsilonTrans) == visited.end())
            {
                stateStack.push(epsilonTrans);
                result.isAccepting = result.isAccepting || states[epsilonTrans].isAccepting;
                visited[epsilonTrans] = true;
            }
        }
    }
    return result;
}

/**
 * @brief 获取一个状态集的epsilon闭包
 * @param stateSet 状态集
 * @param visited 访问标记(用于避免重复访问)
 */
StateSet FA::epsilonClosure(StateSet stateSet, std::unordered_map<int, bool> &visited, FAStateVec &states)
{
    // TODO 空闭包是否需要加入自身?
    StateSet result = stateSet;
    for (auto &stateID : stateSet.set)
    {
        StateSet closure = epsilonClosure(stateID, visited, states);
        result.set.insert(closure.set.begin(), closure.set.end());
        result.isAccepting = result.isAccepting || closure.isAccepting;
    }
    return result;
}

/**
 * @brief 获取一个状态集的转移闭包
 * @param stateSet 状态集
 * @param symbol 转移条件
 */
StateSet FA::move(StateSet stateSet, std::string symbol, FAStateVec &states)
{
    StateSet result;
    // 遍历状态集
    for (auto &stateID : stateSet.set)
    {
        // 查看当前状态是否有symbol转移
        if (states[stateID].trans.find(symbol) != states[stateID].trans.end())
        {
            int nextStateID = states[stateID].trans[symbol];
            result.set.insert(nextStateID);
            result.isAccepting = result.isAccepting || states[nextStateID].isAccepting;
        }
    }
    return result;
}

// /**
//  * @brief 将states中的NFA转换为DFA
//  */
// void FA::toDFA()
// {
//     if (debugMode)
//         printDFATransTableHeader();

//     std::unordered_set<StateSet, StateSetHash, StateSetEqual> visitedSet;
//     std::queue<StateSet> stateSetQueue;

//     StateSet startStateSet = epsilonClosure(NFAStartStateID, NFAStates);
//     // 初始NFA状态集->DFA状态
//     startStateSet.stateID = addState(startStateSet.isAccepting, DFAStates);
//     DFAStartStateID = startStateSet.stateID;

//     // 开始递归 生成DFA
//     stateSetQueue.push(startStateSet);
//     while (!stateSetQueue.empty())
//     {
//         // 获取当前状态集
//         StateSet currentStateSet = stateSetQueue.front();
//         stateSetQueue.pop();

//         // 跳过已访问的状态集
//         if (visitedSet.find(currentStateSet) != visitedSet.end())
//             continue;

//         visitedSet.insert(currentStateSet);

//         if (debugMode)
//         {
//             *outFile << "|" << currentStateSet << "|";
//         }

//         for (auto &symbol : alphabet)
//         {
//             // TODO 生成的nextStateSet的StateID从何而来
//             StateSet nextStateSet = epsilonClosure(move(currentStateSet, symbol, NFAStates), NFAStates);
//             // 跳过空集
//             if (nextStateSet.set.size() == 0)
//             {
//                 if (debugMode)
//                     *outFile << EMPTY_SET << "|";
//                 continue;
//             }

//             // 检查是否为新生成的集合(DFA状态)
//             if (visitedSet.find(nextStateSet) == visitedSet.end())
//             {
//                 // visitedSet.insert(nextStateSet);
//                 nextStateSet.stateID = addState(nextStateSet.isAccepting, DFAStates);
//                 stateSetQueue.push(nextStateSet);
//             }
//             else
//             {
//                 // 重复状态集
//                 // NOTE: 否则StateID会因为epsilonClosure生成出错
//                 nextStateSet = *visitedSet.find(nextStateSet);
//             }

//             if (debugMode)
//             {
//                 *outFile << nextStateSet << "|";
//             }
//             // 为新生成的状态集(DFA状态)添加转移(边)
//             addEdge(currentStateSet.stateID, nextStateSet.stateID, symbol, DFAStates);
//         }

//         if (debugMode)
//             *outFile << std::endl;
//     }
// }